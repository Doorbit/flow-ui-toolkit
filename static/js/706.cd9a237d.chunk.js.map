{"version":3,"file":"static/js/706.cd9a237d.chunk.js","mappings":"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","sources":["utils/normalizeUtils.ts"],"sourcesContent":["import { ListingFlow } from '../models/listingFlow';\nimport { v4 as uuidv4 } from 'uuid';\n\n/**\n * Maps abbreviated type values to their full counterparts for different element types\n */\nconst TYPE_MAPPINGS: Record<string, Record<string, string>> = {\n  DateUIElement: {\n    // enion_esg.json ist die Referenz: es verwendet die Kurzformen 'Y', 'YM', 'YMD'.\n    // Neue Flows sollen ausschließlich diese Werte nutzen.\n    'Y': 'Y',\n    'YM': 'YM',\n    'YMD': 'YMD',\n\n    // Rückwärtskompatibilität: ältere Flows oder Beispiel-Dateien können noch\n    // Langformen wie 'YEAR', 'MONTH', 'DAY' oder 'DATE' enthalten.\n    // Diese werden hier auf die neuen Kurzformen abgebildet.\n    YEAR: 'Y',\n    MONTH: 'YM',\n    DAY: 'YMD',\n    DATE: 'YMD',\n  },\n  BooleanUIElement: {\n    'TOGGLE': 'SWITCH', // Falls in manchen JSONs TOGGLE statt SWITCH verwendet wird\n    'RADIO_BUTTON': 'RADIO', // Normalisierung von RADIO_BUTTON zu RADIO\n    'CHECK': 'CHECKBOX', // Weitere mögliche Variante\n    'BOOL': 'CHECKBOX', // Weitere mögliche Variante\n  },\n  SingleSelectionUIElement: {\n\t\t// Historische Toolkit-Werte wieder auf das Doorbit-Schema abbilden\n\t\t'BUTTONGROUP': 'BUTTON_GROUP', // interne Alt-Schreibweise -> kanonische Schreibweise mit Unterstrich\n\t\t'RADIO_GROUP': 'BUTTON_GROUP', // Weitere mögliche Variante\n\t\t'BUTTON_GROUP': 'BUTTON_GROUP', // Bereits korrekter Wert bleibt erhalten\n    'SELECT': 'DROPDOWN', // Weitere mögliche Variante\n    'COMBOBOX': 'DROPDOWN', // Weitere mögliche Variante\n  },\n  NumberUIElement: {\n    'INT': 'INTEGER', // Falls in manchen JSONs INT statt INTEGER verwendet wird\n    'FLOAT': 'DOUBLE', // Falls in manchen JSONs FLOAT statt DOUBLE verwendet wird\n    'DECIMAL': 'DOUBLE', // Weitere mögliche Variante\n    'NUMBER': 'INTEGER', // Weitere mögliche Variante\n    'REAL': 'DOUBLE', // Weitere mögliche Variante\n  },\n  FileUIElement: {\n    'IMG': 'IMAGE', // Falls in manchen JSONs IMG statt IMAGE verwendet wird\n    'PHOTO': 'IMAGE', // Weitere mögliche Variante\n    'DOCUMENT': 'FILE', // Weitere mögliche Variante\n    'DOC': 'FILE', // Weitere mögliche Variante\n    'ATTACHMENT': 'FILE', // Weitere mögliche Variante\n  },\n  TextUIElement: {\n    'TEXT': 'PARAGRAPH', // Falls in manchen JSONs TEXT statt PARAGRAPH verwendet wird\n    'H1': 'HEADING', // Weitere mögliche Variante\n    'H2': 'HEADING', // Weitere mögliche Variante\n    'HEADER': 'HEADING', // Weitere mögliche Variante\n    'TITLE': 'HEADING', // Weitere mögliche Variante\n    'PLAIN': 'PARAGRAPH', // Weitere mögliche Variante\n  },\n  StringUIElement: {\n    'TEXTAREA': 'TEXT_AREA', // Normalisierung von TEXTAREA zu TEXT_AREA\n    'INPUT': 'TEXT', // Normalisierung von INPUT zu TEXT\n    'MULTILINE': 'TEXT_AREA', // Weitere mögliche Variante\n    'SINGLE_LINE': 'TEXT', // Weitere mögliche Variante\n    'PASSWORD': 'PASSWORD', // Weitere mögliche Variante\n    'EMAIL': 'EMAIL', // Weitere mögliche Variante\n  },\n  CustomUIElement: {\n    'SCANNER': 'SCANNER', // Standardisierung von CustomUIElement-Typen\n    'ADDRESS': 'ADDRESS', // Standardisierung von CustomUIElement-Typen\n    'LOCATION': 'LOCATION', // Standardisierung von CustomUIElement-Typen\n    'ADMIN_BOUNDARY': 'ADMIN_BOUNDARY', // Standardisierung von CustomUIElement-Typen\n    'ENVIRONMENT': 'ENVIRONMENT', // Standardisierung von CustomUIElement-Typen\n  },\n};\n\n/**\n * Normalisiert Elementtypen in einem ListingFlow-Objekt\n * @param flow Das zu normalisierende ListingFlow-Objekt\n * @param ensureFieldIds Ob field_ids sichergestellt werden sollen (Standard: true)\n * @returns Das normalisierte ListingFlow-Objekt\n */\nexport const normalizeElementTypes = (flow: ListingFlow, ensureFieldIds: boolean = true): ListingFlow => {\n  // Deep copy erstellen, um das Original nicht zu verändern\n  const normalizedFlow = JSON.parse(JSON.stringify(flow));\n\n  // Stelle sicher, dass die Grundstruktur vorhanden ist\n  if (!normalizedFlow.id) {\n    normalizedFlow.id = `flow_${uuidv4()}`;\n  }\n\n  if (!normalizedFlow.pages_edit) {\n    normalizedFlow.pages_edit = [];\n  }\n\n  if (!normalizedFlow.pages_view) {\n    normalizedFlow.pages_view = normalizedFlow.pages_edit;\n  }\n\n  // pages_edit normalisieren\n  if (normalizedFlow.pages_edit) {\n    normalizedFlow.pages_edit = normalizedFlow.pages_edit.map((page: any) => {\n      // Stelle sicher, dass die Seite eine ID hat\n      if (!page.id) {\n        page.id = `page_${uuidv4()}`;\n      }\n\n      // Stelle sicher, dass die Seite einen Titel hat\n      if (!page.title) {\n        page.title = { de: 'Neue Seite', en: 'New Page' };\n      } else if (typeof page.title === 'string') {\n        const titleText = page.title;\n        page.title = { de: titleText, en: titleText };\n      }\n\n      // Stelle sicher, dass elements ein Array ist\n      if (!page.elements) {\n        page.elements = [];\n      }\n\n      // Normalisiere die Elemente\n      if (page.elements) {\n        page.elements = page.elements.map((elementWrapper: any) => {\n          // Prüfe, ob das Element bereits ein PatternLibraryElement ist\n          if (elementWrapper.element) {\n            return { element: normalizeElement(elementWrapper.element, ensureFieldIds) };\n          } else {\n            // Wenn nicht, wickle es ein\n            return { element: normalizeElement(elementWrapper, ensureFieldIds) };\n          }\n        });\n      }\n\n      // Auch sub_flows normalisieren, falls vorhanden\n      if (page.sub_flows) {\n        page.sub_flows = page.sub_flows.map((subFlow: any) => {\n          // Stelle sicher, dass der Subflow einen type hat\n          if (!subFlow.type) {\n            subFlow.type = 'SUBFLOW';\n          }\n\n          // Stelle sicher, dass elements ein Array ist\n          if (!subFlow.elements) {\n            subFlow.elements = [];\n          }\n\n          if (subFlow.elements) {\n            subFlow.elements = subFlow.elements.map((elementWrapper: any) => {\n              // Prüfe, ob das Element bereits ein PatternLibraryElement ist\n              if (elementWrapper.element) {\n                return { element: normalizeElement(elementWrapper.element, ensureFieldIds) };\n              } else {\n                // Wenn nicht, wickle es ein\n                return { element: normalizeElement(elementWrapper, ensureFieldIds) };\n              }\n            });\n          }\n          return subFlow;\n        });\n      }\n\n      return page;\n    });\n  }\n\n  // pages_view normalisieren\n  if (normalizedFlow.pages_view) {\n    normalizedFlow.pages_view = normalizedFlow.pages_view.map((page: any) => {\n      // Stelle sicher, dass die Seite eine ID hat\n      if (!page.id) {\n        page.id = `page_${uuidv4()}`;\n      }\n\n      // Stelle sicher, dass die Seite einen Titel hat\n      if (!page.title) {\n        page.title = { de: 'Neue Seite', en: 'New Page' };\n      } else if (typeof page.title === 'string') {\n        const titleText = page.title;\n        page.title = { de: titleText, en: titleText };\n      }\n\n      // Stelle sicher, dass elements ein Array ist\n      if (!page.elements) {\n        page.elements = [];\n      }\n\n      // Normalisiere die Elemente\n      if (page.elements) {\n        page.elements = page.elements.map((elementWrapper: any) => {\n          // Prüfe, ob das Element bereits ein PatternLibraryElement ist\n          if (elementWrapper.element) {\n            return { element: normalizeElement(elementWrapper.element, ensureFieldIds) };\n          } else {\n            // Wenn nicht, wickle es ein\n            return { element: normalizeElement(elementWrapper, ensureFieldIds) };\n          }\n        });\n      }\n      return page;\n    });\n  }\n\n  // Validiere die Struktur\n  const validationResult = validateFlowStructure(normalizedFlow);\n  if (!validationResult.valid) {\n    console.warn('[normalizeElementTypes] Validierungsfehler:', validationResult.errors);\n  }\n\n  return normalizedFlow;\n};\n\n/**\n * Normalisiert ein einzelnes Element und seine verschachtelten Elemente\n * @param element Das zu normalisierende Element\n * @param ensureFieldId Ob eine field_id sichergestellt werden soll (Standard: true)\n * @returns Das normalisierte Element\n */\nconst normalizeElement = (element: any, ensureFieldId: boolean = true): any => {\n  if (!element) {\n    return element;\n  }\n\n  // Wenn das Element kein pattern_type hat, aber einen type hat, könnte es ein Subflow sein\n  if (!element.pattern_type && element.type) {\n    // Normalisiere Subflow-Elemente\n    if (element.elements) {\n      element.elements = element.elements.map((elementWrapper: any) => {\n        // Prüfe, ob das Element bereits ein PatternLibraryElement ist\n        if (elementWrapper.element) {\n          return { element: normalizeElement(elementWrapper.element, ensureFieldId) };\n        } else {\n          // Wenn nicht, wickle es ein\n          return { element: normalizeElement(elementWrapper, ensureFieldId) };\n        }\n      });\n    }\n    return element;\n  }\n\n  // Wenn das Element kein pattern_type hat und auch keinen type, können wir es nicht normalisieren\n  if (!element.pattern_type) {\n    return element;\n  }\n\n  const patternType = element.pattern_type;\n  const typeMapping = TYPE_MAPPINGS[patternType];\n\n  // Stelle sicher, dass eine field_id vorhanden ist\n  if (ensureFieldId && !element.field_id) {\n    console.log(`[normalizeElement] Erzeuge field_id für ${patternType}`);\n    element.field_id = { field_name: `${patternType.toLowerCase()}_${uuidv4()}` };\n  }\n\n  // Stelle sicher, dass title vorhanden ist\n  if (!element.title) {\n    element.title = { de: `Neues ${patternType}`, en: `New ${patternType}` };\n  } else if (typeof element.title === 'string') {\n    // Wenn title ein String ist, konvertiere es zu einem Objekt\n    const titleText = element.title;\n    element.title = { de: titleText, en: titleText };\n  } else if (!element.title.de && element.title.en) {\n    // Wenn nur der englische Titel vorhanden ist, kopiere ihn zum deutschen\n    element.title.de = element.title.en;\n  } else if (!element.title.en && element.title.de) {\n    // Wenn nur der deutsche Titel vorhanden ist, kopiere ihn zum englischen\n    element.title.en = element.title.de;\n  }\n\n  // Stelle sicher, dass description vorhanden ist, wenn es ein Eingabefeld ist\n  if (['StringUIElement', 'NumberUIElement', 'DateUIElement', 'BooleanUIElement', 'SingleSelectionUIElement', 'FileUIElement'].includes(patternType) && !element.description) {\n    element.description = { de: '', en: '' };\n  } else if (element.description && typeof element.description === 'string') {\n    // Wenn description ein String ist, konvertiere es zu einem Objekt\n    const descText = element.description;\n    element.description = { de: descText, en: descText };\n  } else if (element.description && !element.description.de && element.description.en) {\n    // Wenn nur die englische Beschreibung vorhanden ist, kopiere sie zur deutschen\n    element.description.de = element.description.en;\n  } else if (element.description && !element.description.en && element.description.de) {\n    // Wenn nur die deutsche Beschreibung vorhanden ist, kopiere sie zur englischen\n    element.description.en = element.description.de;\n  }\n\n  // Typzuordnung anwenden, falls für diesen pattern_type verfügbar\n  if (typeMapping && element.type && typeMapping[element.type]) {\n    element.type = typeMapping[element.type];\n  }\n\n  // Normalisiere file_type für FileUIElement (falls vorhanden)\n  if (patternType === 'FileUIElement' && element.file_type && typeMapping && typeMapping[element.file_type]) {\n    element.file_type = typeMapping[element.file_type];\n  }\n\n  // Normalisiere Feldnamen (z.B. accepted_types zu allowed_file_types)\n  if (patternType === 'FileUIElement' && element.accepted_types && !element.allowed_file_types) {\n    element.allowed_file_types = element.accepted_types;\n    delete element.accepted_types;\n  }\n\n  // Normalisiere SingleSelectionUIElement items zu options\n  if (patternType === 'SingleSelectionUIElement' && element.items && !element.options) {\n    element.options = element.items;\n    delete element.items;\n  }\n\n  // Normalisiere NumberUIElement default zu default_value\n  if (patternType === 'NumberUIElement' && element.default !== undefined && element.default_value === undefined) {\n    element.default_value = element.default;\n    delete element.default;\n  }\n\n  // Normalisiere visibility_condition\n  if (element.visibility_condition) {\n    element.visibility_condition = normalizeVisibilityCondition(element.visibility_condition);\n  }\n\n  // Rekursiv verschachtelte Elemente normalisieren\n  if (patternType === 'GroupUIElement' && element.elements) {\n    // Prüfe, ob die Elemente bereits PatternLibraryElements sind\n    element.elements = element.elements.map((elementWrapper: any) => {\n      if (elementWrapper.element) {\n        return { element: normalizeElement(elementWrapper.element, ensureFieldId) };\n      } else {\n        return { element: normalizeElement(elementWrapper, ensureFieldId) };\n      }\n    });\n  } else if (patternType === 'ArrayUIElement' && element.elements) {\n    // Prüfe, ob die Elemente bereits PatternLibraryElements sind\n    element.elements = element.elements.map((elementWrapper: any) => {\n      if (elementWrapper.element) {\n        return { element: normalizeElement(elementWrapper.element, ensureFieldId) };\n      } else {\n        return { element: normalizeElement(elementWrapper, ensureFieldId) };\n      }\n    });\n  } else if (patternType === 'CustomUIElement') {\n    // Elemente in CustomUIElement\n    if (element.elements) {\n      element.elements = element.elements.map((elementWrapper: any) => {\n        if (elementWrapper.element) {\n          return { element: normalizeElement(elementWrapper.element, ensureFieldId) };\n        } else {\n          return { element: normalizeElement(elementWrapper, ensureFieldId) };\n        }\n      });\n    }\n\n    // sub_flows in CustomUIElement\n    if (element.sub_flows) {\n      element.sub_flows = element.sub_flows.map((subFlow: any) => {\n        // Stelle sicher, dass der Subflow einen type hat\n        if (!subFlow.type) {\n          subFlow.type = element.type || 'SUBFLOW';\n        }\n\n        if (subFlow.elements) {\n          subFlow.elements = subFlow.elements.map((elementWrapper: any) => {\n            if (elementWrapper.element) {\n              return { element: normalizeElement(elementWrapper.element, ensureFieldId) };\n            } else {\n              return { element: normalizeElement(elementWrapper, ensureFieldId) };\n            }\n          });\n        }\n        return subFlow;\n      });\n    }\n  } else if (patternType === 'ChipGroupUIElement' && element.chips) {\n    // Stelle sicher, dass alle Chips BooleanUIElements sind und eine eindeutige field_id haben\n    element.chips = element.chips.map((chip: any) => {\n      // Wenn der Chip kein pattern_type hat, setze ihn auf BooleanUIElement\n      if (!chip.pattern_type) {\n        chip.pattern_type = 'BooleanUIElement';\n      }\n\n      return normalizeElement(chip, ensureFieldId);\n    });\n  }\n\n  return element;\n};\n\n/**\n * Normalisiert eine Visibility Condition\n * @param condition Die zu normalisierende Visibility Condition\n * @returns Die normalisierte Visibility Condition\n */\nconst normalizeVisibilityCondition = (condition: any): any => {\n  if (!condition) return condition;\n\n  // Wenn die Bedingung ein Array ist, normalisiere jedes Element\n  if (Array.isArray(condition)) {\n    return condition.map(normalizeVisibilityCondition);\n  }\n\n  // Wenn die Bedingung ein Objekt ist\n  if (typeof condition === 'object') {\n    // Normalisiere Operatoren\n    if (condition.operator) {\n      // Konvertiere Operatoren zu Großbuchstaben\n      condition.operator = condition.operator.toUpperCase();\n\n      // Normalisiere logische Operatoren\n      if (['AND', 'OR'].includes(condition.operator) && condition.conditions) {\n        condition.conditions = condition.conditions.map(normalizeVisibilityCondition);\n      }\n\n      // Normalisiere Vergleichsoperatoren\n      if (['EQ', 'NEQ', 'GT', 'GTE', 'LT', 'LTE', 'CONTAINS', 'NOT_CONTAINS'].includes(condition.operator)) {\n        // Stelle sicher, dass field_id ein Objekt ist\n        if (condition.field_id && typeof condition.field_id === 'string') {\n          condition.field_id = { field_name: condition.field_id };\n        }\n      }\n    }\n\n    // Normalisiere alte Formate\n    if (condition.type === 'LO' && condition.value) {\n      // Logischer Operator (AND, OR)\n      condition.operator = condition.value.toUpperCase();\n      delete condition.type;\n      delete condition.value;\n\n      if (condition.children) {\n        condition.conditions = condition.children.map(normalizeVisibilityCondition);\n        delete condition.children;\n      }\n    } else if (condition.type === 'RFO' && condition.field && condition.operator) {\n      // Relativer Feldoperator (EQ, NEQ, etc.)\n      if (typeof condition.field === 'string') {\n        condition.field_id = { field_name: condition.field };\n      } else {\n        condition.field_id = condition.field;\n      }\n      delete condition.field;\n      delete condition.type;\n    }\n  }\n\n  return condition;\n};\n\n/**\n * Validiert die Struktur eines ListingFlow-Objekts\n * @param flow Das zu validierende ListingFlow-Objekt\n * @returns Ein Objekt mit dem Validierungsergebnis und ggf. Fehlern\n */\nexport interface ValidationResult {\n  valid: boolean;\n  errors: string[];\n}\n\nexport const validateFlowStructure = (flow: ListingFlow): ValidationResult => {\n  const errors: string[] = [];\n\n  // Prüfe, ob die Grundstruktur vorhanden ist\n  if (!flow) {\n    errors.push('Flow ist nicht definiert');\n    return { valid: false, errors };\n  }\n\n  if (!flow.id) {\n    errors.push('Flow hat keine ID');\n  }\n\n  if (!flow.pages_edit || !Array.isArray(flow.pages_edit)) {\n    errors.push('Flow hat keine pages_edit oder pages_edit ist kein Array');\n  }\n\n  if (!flow.pages_view || !Array.isArray(flow.pages_view)) {\n    errors.push('Flow hat keine pages_view oder pages_view ist kein Array');\n  }\n\n  // Prüfe die Seiten\n  if (flow.pages_edit) {\n    flow.pages_edit.forEach((page: any, index: number) => {\n      if (!page.id) {\n        errors.push(`Seite ${index} hat keine ID`);\n      }\n\n      if (!page.title) {\n        errors.push(`Seite ${index} hat keinen Titel`);\n      }\n\n      if (!page.elements || !Array.isArray(page.elements)) {\n        errors.push(`Seite ${index} hat keine elements oder elements ist kein Array`);\n      }\n\n      // Prüfe die Elemente\n      if (page.elements) {\n        page.elements.forEach((elementWrapper: any, elementIndex: number) => {\n          if (!elementWrapper.element) {\n            errors.push(`Element ${elementIndex} auf Seite ${index} ist kein PatternLibraryElement`);\n          } else {\n            const elementErrors = validateElement(elementWrapper.element, `Seite ${index}, Element ${elementIndex}`);\n            errors.push(...elementErrors);\n          }\n        });\n      }\n\n      // Prüfe die sub_flows\n      if (page.sub_flows) {\n        if (!Array.isArray(page.sub_flows)) {\n          errors.push(`sub_flows auf Seite ${index} ist kein Array`);\n        } else {\n          page.sub_flows.forEach((subFlow: any, subFlowIndex: number) => {\n            if (!subFlow.type) {\n              errors.push(`Subflow ${subFlowIndex} auf Seite ${index} hat keinen type`);\n            }\n\n            if (!subFlow.elements || !Array.isArray(subFlow.elements)) {\n              errors.push(`Subflow ${subFlowIndex} auf Seite ${index} hat keine elements oder elements ist kein Array`);\n            }\n\n            // Prüfe die Elemente im Subflow\n            if (subFlow.elements) {\n              subFlow.elements.forEach((elementWrapper: any, elementIndex: number) => {\n                if (!elementWrapper.element) {\n                  errors.push(`Element ${elementIndex} in Subflow ${subFlowIndex} auf Seite ${index} ist kein PatternLibraryElement`);\n                } else {\n                  const elementErrors = validateElement(elementWrapper.element, `Seite ${index}, Subflow ${subFlowIndex}, Element ${elementIndex}`);\n                  errors.push(...elementErrors);\n                }\n              });\n            }\n          });\n        }\n      }\n    });\n  }\n\n  return {\n    valid: errors.length === 0,\n    errors\n  };\n};\n\n/**\n * Validiert ein einzelnes Element\n * @param element Das zu validierende Element\n * @param path Der Pfad zum Element (für Fehlermeldungen)\n * @returns Ein Array mit Fehlermeldungen\n */\nconst validateElement = (element: any, path: string): string[] => {\n  const errors: string[] = [];\n\n  if (!element) {\n    errors.push(`${path}: Element ist nicht definiert`);\n    return errors;\n  }\n\n  if (!element.pattern_type) {\n    errors.push(`${path}: Element hat keinen pattern_type`);\n  }\n\n  // Prüfe, ob eine field_id vorhanden ist (außer bei TextUIElement)\n  if (element.pattern_type !== 'TextUIElement' && !element.field_id) {\n    errors.push(`${path}: Element hat keine field_id`);\n  }\n\n  // Prüfe, ob ein Titel vorhanden ist\n  if (!element.title) {\n    errors.push(`${path}: Element hat keinen Titel`);\n  } else if (typeof element.title === 'object' && (!element.title.de || !element.title.en)) {\n    errors.push(`${path}: Element hat keinen vollständigen Titel (de/en)`);\n  }\n\n  // Prüfe spezifische Elementtypen\n  switch (element.pattern_type) {\n    case 'GroupUIElement':\n    case 'ArrayUIElement':\n      if (!element.elements || !Array.isArray(element.elements)) {\n        errors.push(`${path}: ${element.pattern_type} hat keine elements oder elements ist kein Array`);\n      } else {\n        // Prüfe die Unterelemente\n        element.elements.forEach((elementWrapper: any, index: number) => {\n          if (!elementWrapper.element) {\n            errors.push(`${path}, Unterelement ${index}: Element ist kein PatternLibraryElement`);\n          } else {\n            const elementErrors = validateElement(elementWrapper.element, `${path}, Unterelement ${index}`);\n            errors.push(...elementErrors);\n          }\n        });\n      }\n      break;\n\n    case 'CustomUIElement':\n      if (element.sub_flows) {\n        if (!Array.isArray(element.sub_flows)) {\n          errors.push(`${path}: CustomUIElement hat sub_flows, aber sub_flows ist kein Array`);\n        } else {\n          // Prüfe die sub_flows\n          element.sub_flows.forEach((subFlow: any, index: number) => {\n            if (!subFlow.type) {\n              errors.push(`${path}, Subflow ${index}: Subflow hat keinen type`);\n            }\n\n            if (!subFlow.elements || !Array.isArray(subFlow.elements)) {\n              errors.push(`${path}, Subflow ${index}: Subflow hat keine elements oder elements ist kein Array`);\n            } else {\n              // Prüfe die Elemente im Subflow\n              subFlow.elements.forEach((elementWrapper: any, elementIndex: number) => {\n                if (!elementWrapper.element) {\n                  errors.push(`${path}, Subflow ${index}, Element ${elementIndex}: Element ist kein PatternLibraryElement`);\n                } else {\n                  const elementErrors = validateElement(elementWrapper.element, `${path}, Subflow ${index}, Element ${elementIndex}`);\n                  errors.push(...elementErrors);\n                }\n              });\n            }\n          });\n        }\n      }\n      break;\n\n    case 'ChipGroupUIElement':\n      if (!element.chips || !Array.isArray(element.chips)) {\n        errors.push(`${path}: ChipGroupUIElement hat keine chips oder chips ist kein Array`);\n      } else {\n        // Prüfe die Chips\n        element.chips.forEach((chip: any, index: number) => {\n          if (!chip.pattern_type) {\n            errors.push(`${path}, Chip ${index}: Chip hat keinen pattern_type`);\n          } else if (chip.pattern_type !== 'BooleanUIElement') {\n            errors.push(`${path}, Chip ${index}: Chip ist kein BooleanUIElement, sondern ${chip.pattern_type}`);\n          }\n\n          if (!chip.field_id) {\n            errors.push(`${path}, Chip ${index}: Chip hat keine field_id`);\n          }\n        });\n      }\n      break;\n\n    case 'SingleSelectionUIElement':\n      if (!element.options || !Array.isArray(element.options)) {\n        errors.push(`${path}: SingleSelectionUIElement hat keine options oder options ist kein Array`);\n      }\n      break;\n\n    case 'FileUIElement':\n      if (!element.file_type) {\n        errors.push(`${path}: FileUIElement hat keinen file_type`);\n      }\n      break;\n  }\n\n  return errors;\n};\n\n/**\n * Konvertiert ein Element in ein PatternLibraryElement wenn nötig\n * @param element Das zu konvertierende Element\n * @returns Das Element als PatternLibraryElement\n */\nexport const ensurePatternLibraryElement = (element: any): any => {\n  if (element && element.element) {\n    return element;\n  }\n  return { element };\n};\n\n/**\n * Erzwingt die Einwicklung aller Elemente in PatternLibraryElement-Objekte\n * @param flow Das zu verarbeitende ListingFlow-Objekt\n * @returns Das ListingFlow-Objekt mit eingewickelten Elementen\n */\nexport const enforcePatternLibraryElementWrapping = (flow: ListingFlow): ListingFlow => {\n  // Deep copy erstellen, um das Original nicht zu verändern\n  const wrappedFlow = JSON.parse(JSON.stringify(flow));\n\n  // pages_edit verarbeiten\n  if (wrappedFlow.pages_edit) {\n    wrappedFlow.pages_edit = wrappedFlow.pages_edit.map((page: any) => {\n      // Elemente einwickeln\n      if (page.elements) {\n        page.elements = page.elements.map((elementWrapper: any) => {\n          return ensurePatternLibraryElement(elementWrapper);\n        });\n      }\n\n      // sub_flows verarbeiten\n      if (page.sub_flows) {\n        page.sub_flows = page.sub_flows.map((subFlow: any) => {\n          if (subFlow.elements) {\n            subFlow.elements = subFlow.elements.map((elementWrapper: any) => {\n              return ensurePatternLibraryElement(elementWrapper);\n            });\n          }\n          return subFlow;\n        });\n      }\n\n      return page;\n    });\n  }\n\n  // pages_view verarbeiten\n  if (wrappedFlow.pages_view) {\n    wrappedFlow.pages_view = wrappedFlow.pages_view.map((page: any) => {\n      if (page.elements) {\n        page.elements = page.elements.map((elementWrapper: any) => {\n          return ensurePatternLibraryElement(elementWrapper);\n        });\n      }\n      return page;\n    });\n  }\n\n  return wrappedFlow;\n};\n\n/**\n * Normalisiert die Struktur eines ListingFlow-Objekts für komplexe JSON-Strukturen wie doorbit_original.json\n * @param flow Das zu normalisierende ListingFlow-Objekt\n * @returns Das normalisierte ListingFlow-Objekt\n */\nexport const normalizeComplexStructure = (flow: ListingFlow): ListingFlow => {\n  // Zuerst die Grundnormalisierung durchführen\n  let normalizedFlow = normalizeElementTypes(flow);\n\n  // Dann die Einwicklung erzwingen\n  normalizedFlow = enforcePatternLibraryElementWrapping(normalizedFlow);\n\n  // Deep copy erstellen, um das Original nicht zu verändern\n  const complexNormalizedFlow = JSON.parse(JSON.stringify(normalizedFlow));\n\n  // Spezielle Normalisierung für komplexe Strukturen\n  if (complexNormalizedFlow.pages_edit) {\n    complexNormalizedFlow.pages_edit = complexNormalizedFlow.pages_edit.map((page: any) => {\n      // Normalisiere die Elemente rekursiv\n      if (page.elements) {\n        page.elements = normalizeComplexElements(page.elements);\n      }\n\n      // Normalisiere sub_flows\n      if (page.sub_flows) {\n        page.sub_flows = page.sub_flows.map((subFlow: any) => {\n          // Stelle sicher, dass der Subflow einen type hat\n          if (!subFlow.type) {\n            subFlow.type = 'SUBFLOW';\n          }\n\n          // Normalisiere die Elemente im Subflow\n          if (subFlow.elements) {\n            subFlow.elements = normalizeComplexElements(subFlow.elements);\n          }\n\n          return subFlow;\n        });\n      }\n\n      return page;\n    });\n  }\n\n  // Validiere die Struktur\n  const validationResult = validateFlowStructure(complexNormalizedFlow);\n  if (!validationResult.valid) {\n    console.warn('[normalizeComplexStructure] Validierungsfehler:', validationResult.errors);\n  }\n\n  return complexNormalizedFlow;\n};\n\n/**\n * Normalisiert komplexe Elementstrukturen rekursiv\n * @param elements Die zu normalisierenden Elemente\n * @returns Die normalisierten Elemente\n */\nconst normalizeComplexElements = (elements: any[]): any[] => {\n  return elements.map((elementWrapper: any) => {\n    if (!elementWrapper.element) {\n      return elementWrapper;\n    }\n\n    const element = elementWrapper.element;\n\n    // Normalisiere verschachtelte Elemente\n    if (element.pattern_type === 'GroupUIElement' && element.elements) {\n      element.elements = normalizeComplexElements(element.elements);\n    } else if (element.pattern_type === 'ArrayUIElement' && element.elements) {\n      element.elements = normalizeComplexElements(element.elements);\n    } else if (element.pattern_type === 'CustomUIElement') {\n      // Normalisiere Elemente in CustomUIElement\n      if (element.elements) {\n        element.elements = normalizeComplexElements(element.elements);\n      }\n\n      // Normalisiere sub_flows in CustomUIElement\n      if (element.sub_flows) {\n        element.sub_flows = element.sub_flows.map((subFlow: any) => {\n          // Stelle sicher, dass der Subflow einen type hat\n          if (!subFlow.type) {\n            subFlow.type = element.type || 'SUBFLOW';\n          }\n\n          // Normalisiere die Elemente im Subflow\n          if (subFlow.elements) {\n            subFlow.elements = normalizeComplexElements(subFlow.elements);\n          }\n\n          return subFlow;\n        });\n      }\n    }\n\n    // Stelle sicher, dass alle Referenzen auf andere Elemente korrekt sind\n    if (element.visibility_condition) {\n      element.visibility_condition = normalizeVisibilityCondition(element.visibility_condition);\n    }\n\n    return elementWrapper;\n  });\n};\n"],"names":["TYPE_MAPPINGS","DateUIElement","YEAR","MONTH","DAY","DATE","BooleanUIElement","SingleSelectionUIElement","NumberUIElement","FileUIElement","TextUIElement","StringUIElement","CustomUIElement","normalizeElementTypes","flow","ensureFieldIds","arguments","length","undefined","normalizedFlow","JSON","parse","stringify","id","concat","uuidv4","pages_edit","pages_view","map","page","title","titleText","de","en","elements","elementWrapper","element","normalizeElement","sub_flows","subFlow","type","validationResult","validateFlowStructure","valid","console","warn","errors","ensureFieldId","pattern_type","patternType","typeMapping","field_id","log","field_name","toLowerCase","includes","description","descText","file_type","accepted_types","allowed_file_types","items","options","default","default_value","visibility_condition","normalizeVisibilityCondition","chips","chip","condition","Array","isArray","operator","toUpperCase","conditions","value","children","field","push","forEach","index","elementIndex","elementErrors","validateElement","subFlowIndex","path","ensurePatternLibraryElement","enforcePatternLibraryElementWrapping","wrappedFlow","normalizeComplexStructure","complexNormalizedFlow","normalizeComplexElements"],"sourceRoot":""}