{"version":3,"file":"static/js/706.01e6d010.chunk.js","mappings":"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","sources":["utils/normalizeUtils.ts"],"sourcesContent":["import { ListingFlow } from '../models/listingFlow';\r\nimport { v4 as uuidv4 } from 'uuid';\r\n\r\n/**\r\n * Maps abbreviated type values to their full counterparts for different element types\r\n */\r\nconst TYPE_MAPPINGS: Record<string, Record<string, string>> = {\r\n  DateUIElement: {\r\n    // enion_esg.json ist die Referenz: es verwendet die Kurzformen 'Y', 'YM', 'YMD'.\r\n    // Neue Flows sollen ausschließlich diese Werte nutzen.\r\n    'Y': 'Y',\r\n    'YM': 'YM',\r\n    'YMD': 'YMD',\r\n\r\n    // Rückwärtskompatibilität: ältere Flows oder Beispiel-Dateien können noch\r\n    // Langformen wie 'YEAR', 'MONTH', 'DAY' oder 'DATE' enthalten.\r\n    // Diese werden hier auf die neuen Kurzformen abgebildet.\r\n    YEAR: 'Y',\r\n    MONTH: 'YM',\r\n    DAY: 'YMD',\r\n    DATE: 'YMD',\r\n  },\r\n  BooleanUIElement: {\r\n    'TOGGLE': 'SWITCH', // Falls in manchen JSONs TOGGLE statt SWITCH verwendet wird\r\n    'RADIO_BUTTON': 'RADIO', // Normalisierung von RADIO_BUTTON zu RADIO\r\n    'CHECK': 'CHECKBOX', // Weitere mögliche Variante\r\n    'BOOL': 'CHECKBOX', // Weitere mögliche Variante\r\n  },\r\n  SingleSelectionUIElement: {\r\n\t\t// Historische Toolkit-Werte wieder auf das Doorbit-Schema abbilden\r\n\t\t'BUTTONGROUP': 'BUTTON_GROUP', // interne Alt-Schreibweise -> kanonische Schreibweise mit Unterstrich\r\n\t\t'RADIO_GROUP': 'BUTTON_GROUP', // Weitere mögliche Variante\r\n\t\t'BUTTON_GROUP': 'BUTTON_GROUP', // Bereits korrekter Wert bleibt erhalten\r\n    'SELECT': 'DROPDOWN', // Weitere mögliche Variante\r\n    'COMBOBOX': 'DROPDOWN', // Weitere mögliche Variante\r\n  },\r\n  NumberUIElement: {\r\n    'INT': 'INTEGER', // Falls in manchen JSONs INT statt INTEGER verwendet wird\r\n    'FLOAT': 'DOUBLE', // Falls in manchen JSONs FLOAT statt DOUBLE verwendet wird\r\n    'DECIMAL': 'DOUBLE', // Weitere mögliche Variante\r\n    'NUMBER': 'INTEGER', // Weitere mögliche Variante\r\n    'REAL': 'DOUBLE', // Weitere mögliche Variante\r\n  },\r\n  FileUIElement: {\r\n    'IMG': 'IMAGE', // Falls in manchen JSONs IMG statt IMAGE verwendet wird\r\n    'PHOTO': 'IMAGE', // Weitere mögliche Variante\r\n    'DOCUMENT': 'FILE', // Weitere mögliche Variante\r\n    'DOC': 'FILE', // Weitere mögliche Variante\r\n    'ATTACHMENT': 'FILE', // Weitere mögliche Variante\r\n  },\r\n  TextUIElement: {\r\n    'TEXT': 'PARAGRAPH', // Falls in manchen JSONs TEXT statt PARAGRAPH verwendet wird\r\n    'H1': 'HEADING', // Weitere mögliche Variante\r\n    'H2': 'HEADING', // Weitere mögliche Variante\r\n    'HEADER': 'HEADING', // Weitere mögliche Variante\r\n    'TITLE': 'HEADING', // Weitere mögliche Variante\r\n    'PLAIN': 'PARAGRAPH', // Weitere mögliche Variante\r\n  },\r\n  StringUIElement: {\r\n    'TEXTAREA': 'TEXT_AREA', // Normalisierung von TEXTAREA zu TEXT_AREA\r\n    'INPUT': 'TEXT', // Normalisierung von INPUT zu TEXT\r\n    'MULTILINE': 'TEXT_AREA', // Weitere mögliche Variante\r\n    'SINGLE_LINE': 'TEXT', // Weitere mögliche Variante\r\n    'PASSWORD': 'PASSWORD', // Weitere mögliche Variante\r\n    'EMAIL': 'EMAIL', // Weitere mögliche Variante\r\n  },\r\n  CustomUIElement: {\r\n    'SCANNER': 'SCANNER', // Standardisierung von CustomUIElement-Typen\r\n    'ADDRESS': 'ADDRESS', // Standardisierung von CustomUIElement-Typen\r\n    'LOCATION': 'LOCATION', // Standardisierung von CustomUIElement-Typen\r\n    'ADMIN_BOUNDARY': 'ADMIN_BOUNDARY', // Standardisierung von CustomUIElement-Typen\r\n    'ENVIRONMENT': 'ENVIRONMENT', // Standardisierung von CustomUIElement-Typen\r\n  },\r\n};\r\n\r\n/**\r\n * Normalisiert Elementtypen in einem ListingFlow-Objekt\r\n * @param flow Das zu normalisierende ListingFlow-Objekt\r\n * @param ensureFieldIds Ob field_ids sichergestellt werden sollen (Standard: true)\r\n * @returns Das normalisierte ListingFlow-Objekt\r\n */\r\nexport const normalizeElementTypes = (flow: ListingFlow, ensureFieldIds: boolean = true): ListingFlow => {\r\n  // Deep copy erstellen, um das Original nicht zu verändern\r\n  const normalizedFlow = JSON.parse(JSON.stringify(flow));\r\n\r\n  // Stelle sicher, dass die Grundstruktur vorhanden ist\r\n  if (!normalizedFlow.id) {\r\n    normalizedFlow.id = `flow_${uuidv4()}`;\r\n  }\r\n\r\n  if (!normalizedFlow.pages_edit) {\r\n    normalizedFlow.pages_edit = [];\r\n  }\r\n\r\n  if (!normalizedFlow.pages_view) {\r\n    normalizedFlow.pages_view = normalizedFlow.pages_edit;\r\n  }\r\n\r\n  // pages_edit normalisieren\r\n  if (normalizedFlow.pages_edit) {\r\n    normalizedFlow.pages_edit = normalizedFlow.pages_edit.map((page: any) => {\r\n      // Stelle sicher, dass die Seite eine ID hat\r\n      if (!page.id) {\r\n        page.id = `page_${uuidv4()}`;\r\n      }\r\n\r\n      // Stelle sicher, dass die Seite einen Titel hat\r\n      if (!page.title) {\r\n        page.title = { de: 'Neue Seite', en: 'New Page' };\r\n      } else if (typeof page.title === 'string') {\r\n        const titleText = page.title;\r\n        page.title = { de: titleText, en: titleText };\r\n      }\r\n\r\n      // Stelle sicher, dass elements ein Array ist\r\n      if (!page.elements) {\r\n        page.elements = [];\r\n      }\r\n\r\n      // Normalisiere die Elemente\r\n      if (page.elements) {\r\n        page.elements = page.elements.map((elementWrapper: any) => {\r\n          // Prüfe, ob das Element bereits ein PatternLibraryElement ist\r\n          if (elementWrapper.element) {\r\n            return { element: normalizeElement(elementWrapper.element, ensureFieldIds) };\r\n          } else {\r\n            // Wenn nicht, wickle es ein\r\n            return { element: normalizeElement(elementWrapper, ensureFieldIds) };\r\n          }\r\n        });\r\n      }\r\n\r\n      // Auch sub_flows normalisieren, falls vorhanden\r\n      if (page.sub_flows) {\r\n        page.sub_flows = page.sub_flows.map((subFlow: any) => {\r\n          // Stelle sicher, dass der Subflow einen type hat\r\n          if (!subFlow.type) {\r\n            subFlow.type = 'SUBFLOW';\r\n          }\r\n\r\n          // Stelle sicher, dass elements ein Array ist\r\n          if (!subFlow.elements) {\r\n            subFlow.elements = [];\r\n          }\r\n\r\n          if (subFlow.elements) {\r\n            subFlow.elements = subFlow.elements.map((elementWrapper: any) => {\r\n              // Prüfe, ob das Element bereits ein PatternLibraryElement ist\r\n              if (elementWrapper.element) {\r\n                return { element: normalizeElement(elementWrapper.element, ensureFieldIds) };\r\n              } else {\r\n                // Wenn nicht, wickle es ein\r\n                return { element: normalizeElement(elementWrapper, ensureFieldIds) };\r\n              }\r\n            });\r\n          }\r\n          return subFlow;\r\n        });\r\n      }\r\n\r\n      return page;\r\n    });\r\n  }\r\n\r\n  // pages_view normalisieren\r\n  if (normalizedFlow.pages_view) {\r\n    normalizedFlow.pages_view = normalizedFlow.pages_view.map((page: any) => {\r\n      // Stelle sicher, dass die Seite eine ID hat\r\n      if (!page.id) {\r\n        page.id = `page_${uuidv4()}`;\r\n      }\r\n\r\n      // Stelle sicher, dass die Seite einen Titel hat\r\n      if (!page.title) {\r\n        page.title = { de: 'Neue Seite', en: 'New Page' };\r\n      } else if (typeof page.title === 'string') {\r\n        const titleText = page.title;\r\n        page.title = { de: titleText, en: titleText };\r\n      }\r\n\r\n      // Stelle sicher, dass elements ein Array ist\r\n      if (!page.elements) {\r\n        page.elements = [];\r\n      }\r\n\r\n      // Normalisiere die Elemente\r\n      if (page.elements) {\r\n        page.elements = page.elements.map((elementWrapper: any) => {\r\n          // Prüfe, ob das Element bereits ein PatternLibraryElement ist\r\n          if (elementWrapper.element) {\r\n            return { element: normalizeElement(elementWrapper.element, ensureFieldIds) };\r\n          } else {\r\n            // Wenn nicht, wickle es ein\r\n            return { element: normalizeElement(elementWrapper, ensureFieldIds) };\r\n          }\r\n        });\r\n      }\r\n      return page;\r\n    });\r\n  }\r\n\r\n  // Validiere die Struktur\r\n  const validationResult = validateFlowStructure(normalizedFlow);\r\n  if (!validationResult.valid) {\r\n    console.warn('[normalizeElementTypes] Validierungsfehler:', validationResult.errors);\r\n  }\r\n\r\n  return normalizedFlow;\r\n};\r\n\r\n/**\r\n * Normalisiert ein einzelnes Element und seine verschachtelten Elemente\r\n * @param element Das zu normalisierende Element\r\n * @param ensureFieldId Ob eine field_id sichergestellt werden soll (Standard: true)\r\n * @returns Das normalisierte Element\r\n */\r\nconst normalizeElement = (element: any, ensureFieldId: boolean = true): any => {\r\n  if (!element) {\r\n    return element;\r\n  }\r\n\r\n  // Wenn das Element kein pattern_type hat, aber einen type hat, könnte es ein Subflow sein\r\n  if (!element.pattern_type && element.type) {\r\n    // Normalisiere Subflow-Elemente\r\n    if (element.elements) {\r\n      element.elements = element.elements.map((elementWrapper: any) => {\r\n        // Prüfe, ob das Element bereits ein PatternLibraryElement ist\r\n        if (elementWrapper.element) {\r\n          return { element: normalizeElement(elementWrapper.element, ensureFieldId) };\r\n        } else {\r\n          // Wenn nicht, wickle es ein\r\n          return { element: normalizeElement(elementWrapper, ensureFieldId) };\r\n        }\r\n      });\r\n    }\r\n    return element;\r\n  }\r\n\r\n  // Wenn das Element kein pattern_type hat und auch keinen type, können wir es nicht normalisieren\r\n  if (!element.pattern_type) {\r\n    return element;\r\n  }\r\n\r\n  const patternType = element.pattern_type;\r\n  const typeMapping = TYPE_MAPPINGS[patternType];\r\n\r\n  // Stelle sicher, dass eine field_id vorhanden ist\r\n  if (ensureFieldId && !element.field_id) {\r\n    console.log(`[normalizeElement] Erzeuge field_id für ${patternType}`);\r\n    element.field_id = { field_name: `${patternType.toLowerCase()}_${uuidv4()}` };\r\n  }\r\n\r\n  // Stelle sicher, dass title vorhanden ist\r\n  if (!element.title) {\r\n    element.title = { de: `Neues ${patternType}`, en: `New ${patternType}` };\r\n  } else if (typeof element.title === 'string') {\r\n    // Wenn title ein String ist, konvertiere es zu einem Objekt\r\n    const titleText = element.title;\r\n    element.title = { de: titleText, en: titleText };\r\n  } else if (!element.title.de && element.title.en) {\r\n    // Wenn nur der englische Titel vorhanden ist, kopiere ihn zum deutschen\r\n    element.title.de = element.title.en;\r\n  } else if (!element.title.en && element.title.de) {\r\n    // Wenn nur der deutsche Titel vorhanden ist, kopiere ihn zum englischen\r\n    element.title.en = element.title.de;\r\n  }\r\n\r\n  // Stelle sicher, dass description vorhanden ist, wenn es ein Eingabefeld ist\r\n  if (['StringUIElement', 'NumberUIElement', 'DateUIElement', 'BooleanUIElement', 'SingleSelectionUIElement', 'FileUIElement'].includes(patternType) && !element.description) {\r\n    element.description = { de: '', en: '' };\r\n  } else if (element.description && typeof element.description === 'string') {\r\n    // Wenn description ein String ist, konvertiere es zu einem Objekt\r\n    const descText = element.description;\r\n    element.description = { de: descText, en: descText };\r\n  } else if (element.description && !element.description.de && element.description.en) {\r\n    // Wenn nur die englische Beschreibung vorhanden ist, kopiere sie zur deutschen\r\n    element.description.de = element.description.en;\r\n  } else if (element.description && !element.description.en && element.description.de) {\r\n    // Wenn nur die deutsche Beschreibung vorhanden ist, kopiere sie zur englischen\r\n    element.description.en = element.description.de;\r\n  }\r\n\r\n  // Typzuordnung anwenden, falls für diesen pattern_type verfügbar\r\n  if (typeMapping && element.type && typeMapping[element.type]) {\r\n    element.type = typeMapping[element.type];\r\n  }\r\n\r\n  // Normalisiere file_type für FileUIElement (falls vorhanden)\r\n  if (patternType === 'FileUIElement' && element.file_type && typeMapping && typeMapping[element.file_type]) {\r\n    element.file_type = typeMapping[element.file_type];\r\n  }\r\n\r\n  // Normalisiere Feldnamen (z.B. accepted_types zu allowed_file_types)\r\n  if (patternType === 'FileUIElement' && element.accepted_types && !element.allowed_file_types) {\r\n    element.allowed_file_types = element.accepted_types;\r\n    delete element.accepted_types;\r\n  }\r\n\r\n  // Normalisiere SingleSelectionUIElement items zu options\r\n  if (patternType === 'SingleSelectionUIElement' && element.items && !element.options) {\r\n    element.options = element.items;\r\n    delete element.items;\r\n  }\r\n\r\n  // Normalisiere NumberUIElement default zu default_value\r\n  if (patternType === 'NumberUIElement' && element.default !== undefined && element.default_value === undefined) {\r\n    element.default_value = element.default;\r\n    delete element.default;\r\n  }\r\n\r\n  // Normalisiere visibility_condition\r\n  if (element.visibility_condition) {\r\n    element.visibility_condition = normalizeVisibilityCondition(element.visibility_condition);\r\n  }\r\n\r\n  // Rekursiv verschachtelte Elemente normalisieren\r\n  if (patternType === 'GroupUIElement' && element.elements) {\r\n    // Prüfe, ob die Elemente bereits PatternLibraryElements sind\r\n    element.elements = element.elements.map((elementWrapper: any) => {\r\n      if (elementWrapper.element) {\r\n        return { element: normalizeElement(elementWrapper.element, ensureFieldId) };\r\n      } else {\r\n        return { element: normalizeElement(elementWrapper, ensureFieldId) };\r\n      }\r\n    });\r\n  } else if (patternType === 'ArrayUIElement' && element.elements) {\r\n    // Prüfe, ob die Elemente bereits PatternLibraryElements sind\r\n    element.elements = element.elements.map((elementWrapper: any) => {\r\n      if (elementWrapper.element) {\r\n        return { element: normalizeElement(elementWrapper.element, ensureFieldId) };\r\n      } else {\r\n        return { element: normalizeElement(elementWrapper, ensureFieldId) };\r\n      }\r\n    });\r\n  } else if (patternType === 'CustomUIElement') {\r\n    // Elemente in CustomUIElement\r\n    if (element.elements) {\r\n      element.elements = element.elements.map((elementWrapper: any) => {\r\n        if (elementWrapper.element) {\r\n          return { element: normalizeElement(elementWrapper.element, ensureFieldId) };\r\n        } else {\r\n          return { element: normalizeElement(elementWrapper, ensureFieldId) };\r\n        }\r\n      });\r\n    }\r\n\r\n    // sub_flows in CustomUIElement\r\n    if (element.sub_flows) {\r\n      element.sub_flows = element.sub_flows.map((subFlow: any) => {\r\n        // Stelle sicher, dass der Subflow einen type hat\r\n        if (!subFlow.type) {\r\n          subFlow.type = element.type || 'SUBFLOW';\r\n        }\r\n\r\n        if (subFlow.elements) {\r\n          subFlow.elements = subFlow.elements.map((elementWrapper: any) => {\r\n            if (elementWrapper.element) {\r\n              return { element: normalizeElement(elementWrapper.element, ensureFieldId) };\r\n            } else {\r\n              return { element: normalizeElement(elementWrapper, ensureFieldId) };\r\n            }\r\n          });\r\n        }\r\n        return subFlow;\r\n      });\r\n    }\r\n  } else if (patternType === 'ChipGroupUIElement' && element.chips) {\r\n    // Stelle sicher, dass alle Chips BooleanUIElements sind und eine eindeutige field_id haben\r\n    element.chips = element.chips.map((chip: any) => {\r\n      // Wenn der Chip kein pattern_type hat, setze ihn auf BooleanUIElement\r\n      if (!chip.pattern_type) {\r\n        chip.pattern_type = 'BooleanUIElement';\r\n      }\r\n\r\n      return normalizeElement(chip, ensureFieldId);\r\n    });\r\n  }\r\n\r\n  return element;\r\n};\r\n\r\n/**\r\n * Normalisiert eine Visibility Condition\r\n * @param condition Die zu normalisierende Visibility Condition\r\n * @returns Die normalisierte Visibility Condition\r\n */\r\nconst normalizeVisibilityCondition = (condition: any): any => {\r\n  if (!condition) return condition;\r\n\r\n  // Wenn die Bedingung ein Array ist, normalisiere jedes Element\r\n  if (Array.isArray(condition)) {\r\n    return condition.map(normalizeVisibilityCondition);\r\n  }\r\n\r\n  // Wenn die Bedingung ein Objekt ist\r\n  if (typeof condition === 'object') {\r\n    // Normalisiere Operatoren\r\n    if (condition.operator) {\r\n      // Konvertiere Operatoren zu Großbuchstaben\r\n      condition.operator = condition.operator.toUpperCase();\r\n\r\n      // Normalisiere logische Operatoren\r\n      if (['AND', 'OR'].includes(condition.operator) && condition.conditions) {\r\n        condition.conditions = condition.conditions.map(normalizeVisibilityCondition);\r\n      }\r\n\r\n      // Normalisiere Vergleichsoperatoren\r\n      if (['EQ', 'NEQ', 'GT', 'GTE', 'LT', 'LTE', 'CONTAINS', 'NOT_CONTAINS'].includes(condition.operator)) {\r\n        // Stelle sicher, dass field_id ein Objekt ist\r\n        if (condition.field_id && typeof condition.field_id === 'string') {\r\n          condition.field_id = { field_name: condition.field_id };\r\n        }\r\n      }\r\n    }\r\n\r\n    // Normalisiere alte Formate\r\n    if (condition.type === 'LO' && condition.value) {\r\n      // Logischer Operator (AND, OR)\r\n      condition.operator = condition.value.toUpperCase();\r\n      delete condition.type;\r\n      delete condition.value;\r\n\r\n      if (condition.children) {\r\n        condition.conditions = condition.children.map(normalizeVisibilityCondition);\r\n        delete condition.children;\r\n      }\r\n    } else if (condition.type === 'RFO' && condition.field && condition.operator) {\r\n      // Relativer Feldoperator (EQ, NEQ, etc.)\r\n      if (typeof condition.field === 'string') {\r\n        condition.field_id = { field_name: condition.field };\r\n      } else {\r\n        condition.field_id = condition.field;\r\n      }\r\n      delete condition.field;\r\n      delete condition.type;\r\n    }\r\n  }\r\n\r\n  return condition;\r\n};\r\n\r\n/**\r\n * Validiert die Struktur eines ListingFlow-Objekts\r\n * @param flow Das zu validierende ListingFlow-Objekt\r\n * @returns Ein Objekt mit dem Validierungsergebnis und ggf. Fehlern\r\n */\r\nexport interface ValidationResult {\r\n  valid: boolean;\r\n  errors: string[];\r\n}\r\n\r\nexport const validateFlowStructure = (flow: ListingFlow): ValidationResult => {\r\n  const errors: string[] = [];\r\n\r\n  // Prüfe, ob die Grundstruktur vorhanden ist\r\n  if (!flow) {\r\n    errors.push('Flow ist nicht definiert');\r\n    return { valid: false, errors };\r\n  }\r\n\r\n  if (!flow.id) {\r\n    errors.push('Flow hat keine ID');\r\n  }\r\n\r\n  if (!flow.pages_edit || !Array.isArray(flow.pages_edit)) {\r\n    errors.push('Flow hat keine pages_edit oder pages_edit ist kein Array');\r\n  }\r\n\r\n  if (!flow.pages_view || !Array.isArray(flow.pages_view)) {\r\n    errors.push('Flow hat keine pages_view oder pages_view ist kein Array');\r\n  }\r\n\r\n  // Prüfe die Seiten\r\n  if (flow.pages_edit) {\r\n    flow.pages_edit.forEach((page: any, index: number) => {\r\n      if (!page.id) {\r\n        errors.push(`Seite ${index} hat keine ID`);\r\n      }\r\n\r\n      if (!page.title) {\r\n        errors.push(`Seite ${index} hat keinen Titel`);\r\n      }\r\n\r\n      if (!page.elements || !Array.isArray(page.elements)) {\r\n        errors.push(`Seite ${index} hat keine elements oder elements ist kein Array`);\r\n      }\r\n\r\n      // Prüfe die Elemente\r\n      if (page.elements) {\r\n        page.elements.forEach((elementWrapper: any, elementIndex: number) => {\r\n          if (!elementWrapper.element) {\r\n            errors.push(`Element ${elementIndex} auf Seite ${index} ist kein PatternLibraryElement`);\r\n          } else {\r\n            const elementErrors = validateElement(elementWrapper.element, `Seite ${index}, Element ${elementIndex}`);\r\n            errors.push(...elementErrors);\r\n          }\r\n        });\r\n      }\r\n\r\n      // Prüfe die sub_flows\r\n      if (page.sub_flows) {\r\n        if (!Array.isArray(page.sub_flows)) {\r\n          errors.push(`sub_flows auf Seite ${index} ist kein Array`);\r\n        } else {\r\n          page.sub_flows.forEach((subFlow: any, subFlowIndex: number) => {\r\n            if (!subFlow.type) {\r\n              errors.push(`Subflow ${subFlowIndex} auf Seite ${index} hat keinen type`);\r\n            }\r\n\r\n            if (!subFlow.elements || !Array.isArray(subFlow.elements)) {\r\n              errors.push(`Subflow ${subFlowIndex} auf Seite ${index} hat keine elements oder elements ist kein Array`);\r\n            }\r\n\r\n            // Prüfe die Elemente im Subflow\r\n            if (subFlow.elements) {\r\n              subFlow.elements.forEach((elementWrapper: any, elementIndex: number) => {\r\n                if (!elementWrapper.element) {\r\n                  errors.push(`Element ${elementIndex} in Subflow ${subFlowIndex} auf Seite ${index} ist kein PatternLibraryElement`);\r\n                } else {\r\n                  const elementErrors = validateElement(elementWrapper.element, `Seite ${index}, Subflow ${subFlowIndex}, Element ${elementIndex}`);\r\n                  errors.push(...elementErrors);\r\n                }\r\n              });\r\n            }\r\n          });\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  return {\r\n    valid: errors.length === 0,\r\n    errors\r\n  };\r\n};\r\n\r\n/**\r\n * Validiert ein einzelnes Element\r\n * @param element Das zu validierende Element\r\n * @param path Der Pfad zum Element (für Fehlermeldungen)\r\n * @returns Ein Array mit Fehlermeldungen\r\n */\r\nconst validateElement = (element: any, path: string): string[] => {\r\n  const errors: string[] = [];\r\n\r\n  if (!element) {\r\n    errors.push(`${path}: Element ist nicht definiert`);\r\n    return errors;\r\n  }\r\n\r\n  if (!element.pattern_type) {\r\n    errors.push(`${path}: Element hat keinen pattern_type`);\r\n  }\r\n\r\n  // Prüfe, ob eine field_id vorhanden ist (außer bei TextUIElement)\r\n  if (element.pattern_type !== 'TextUIElement' && !element.field_id) {\r\n    errors.push(`${path}: Element hat keine field_id`);\r\n  }\r\n\r\n  // Prüfe, ob ein Titel vorhanden ist\r\n  if (!element.title) {\r\n    errors.push(`${path}: Element hat keinen Titel`);\r\n  } else if (typeof element.title === 'object' && (!element.title.de || !element.title.en)) {\r\n    errors.push(`${path}: Element hat keinen vollständigen Titel (de/en)`);\r\n  }\r\n\r\n  // Prüfe spezifische Elementtypen\r\n  switch (element.pattern_type) {\r\n    case 'GroupUIElement':\r\n    case 'ArrayUIElement':\r\n      if (!element.elements || !Array.isArray(element.elements)) {\r\n        errors.push(`${path}: ${element.pattern_type} hat keine elements oder elements ist kein Array`);\r\n      } else {\r\n        // Prüfe die Unterelemente\r\n        element.elements.forEach((elementWrapper: any, index: number) => {\r\n          if (!elementWrapper.element) {\r\n            errors.push(`${path}, Unterelement ${index}: Element ist kein PatternLibraryElement`);\r\n          } else {\r\n            const elementErrors = validateElement(elementWrapper.element, `${path}, Unterelement ${index}`);\r\n            errors.push(...elementErrors);\r\n          }\r\n        });\r\n      }\r\n      break;\r\n\r\n    case 'CustomUIElement':\r\n      if (element.sub_flows) {\r\n        if (!Array.isArray(element.sub_flows)) {\r\n          errors.push(`${path}: CustomUIElement hat sub_flows, aber sub_flows ist kein Array`);\r\n        } else {\r\n          // Prüfe die sub_flows\r\n          element.sub_flows.forEach((subFlow: any, index: number) => {\r\n            if (!subFlow.type) {\r\n              errors.push(`${path}, Subflow ${index}: Subflow hat keinen type`);\r\n            }\r\n\r\n            if (!subFlow.elements || !Array.isArray(subFlow.elements)) {\r\n              errors.push(`${path}, Subflow ${index}: Subflow hat keine elements oder elements ist kein Array`);\r\n            } else {\r\n              // Prüfe die Elemente im Subflow\r\n              subFlow.elements.forEach((elementWrapper: any, elementIndex: number) => {\r\n                if (!elementWrapper.element) {\r\n                  errors.push(`${path}, Subflow ${index}, Element ${elementIndex}: Element ist kein PatternLibraryElement`);\r\n                } else {\r\n                  const elementErrors = validateElement(elementWrapper.element, `${path}, Subflow ${index}, Element ${elementIndex}`);\r\n                  errors.push(...elementErrors);\r\n                }\r\n              });\r\n            }\r\n          });\r\n        }\r\n      }\r\n      break;\r\n\r\n    case 'ChipGroupUIElement':\r\n      if (!element.chips || !Array.isArray(element.chips)) {\r\n        errors.push(`${path}: ChipGroupUIElement hat keine chips oder chips ist kein Array`);\r\n      } else {\r\n        // Prüfe die Chips\r\n        element.chips.forEach((chip: any, index: number) => {\r\n          if (!chip.pattern_type) {\r\n            errors.push(`${path}, Chip ${index}: Chip hat keinen pattern_type`);\r\n          } else if (chip.pattern_type !== 'BooleanUIElement') {\r\n            errors.push(`${path}, Chip ${index}: Chip ist kein BooleanUIElement, sondern ${chip.pattern_type}`);\r\n          }\r\n\r\n          if (!chip.field_id) {\r\n            errors.push(`${path}, Chip ${index}: Chip hat keine field_id`);\r\n          }\r\n        });\r\n      }\r\n      break;\r\n\r\n    case 'SingleSelectionUIElement':\r\n      if (!element.options || !Array.isArray(element.options)) {\r\n        errors.push(`${path}: SingleSelectionUIElement hat keine options oder options ist kein Array`);\r\n      }\r\n      break;\r\n\r\n    case 'FileUIElement':\r\n      if (!element.file_type) {\r\n        errors.push(`${path}: FileUIElement hat keinen file_type`);\r\n      }\r\n      break;\r\n  }\r\n\r\n  return errors;\r\n};\r\n\r\n/**\r\n * Konvertiert ein Element in ein PatternLibraryElement wenn nötig\r\n * @param element Das zu konvertierende Element\r\n * @returns Das Element als PatternLibraryElement\r\n */\r\nexport const ensurePatternLibraryElement = (element: any): any => {\r\n  if (element && element.element) {\r\n    return element;\r\n  }\r\n  return { element };\r\n};\r\n\r\n/**\r\n * Erzwingt die Einwicklung aller Elemente in PatternLibraryElement-Objekte\r\n * @param flow Das zu verarbeitende ListingFlow-Objekt\r\n * @returns Das ListingFlow-Objekt mit eingewickelten Elementen\r\n */\r\nexport const enforcePatternLibraryElementWrapping = (flow: ListingFlow): ListingFlow => {\r\n  // Deep copy erstellen, um das Original nicht zu verändern\r\n  const wrappedFlow = JSON.parse(JSON.stringify(flow));\r\n\r\n  // pages_edit verarbeiten\r\n  if (wrappedFlow.pages_edit) {\r\n    wrappedFlow.pages_edit = wrappedFlow.pages_edit.map((page: any) => {\r\n      // Elemente einwickeln\r\n      if (page.elements) {\r\n        page.elements = page.elements.map((elementWrapper: any) => {\r\n          return ensurePatternLibraryElement(elementWrapper);\r\n        });\r\n      }\r\n\r\n      // sub_flows verarbeiten\r\n      if (page.sub_flows) {\r\n        page.sub_flows = page.sub_flows.map((subFlow: any) => {\r\n          if (subFlow.elements) {\r\n            subFlow.elements = subFlow.elements.map((elementWrapper: any) => {\r\n              return ensurePatternLibraryElement(elementWrapper);\r\n            });\r\n          }\r\n          return subFlow;\r\n        });\r\n      }\r\n\r\n      return page;\r\n    });\r\n  }\r\n\r\n  // pages_view verarbeiten\r\n  if (wrappedFlow.pages_view) {\r\n    wrappedFlow.pages_view = wrappedFlow.pages_view.map((page: any) => {\r\n      if (page.elements) {\r\n        page.elements = page.elements.map((elementWrapper: any) => {\r\n          return ensurePatternLibraryElement(elementWrapper);\r\n        });\r\n      }\r\n      return page;\r\n    });\r\n  }\r\n\r\n  return wrappedFlow;\r\n};\r\n\r\n/**\r\n * Normalisiert die Struktur eines ListingFlow-Objekts für komplexe JSON-Strukturen wie doorbit_original.json\r\n * @param flow Das zu normalisierende ListingFlow-Objekt\r\n * @returns Das normalisierte ListingFlow-Objekt\r\n */\r\nexport const normalizeComplexStructure = (flow: ListingFlow): ListingFlow => {\r\n  // Zuerst die Grundnormalisierung durchführen\r\n  let normalizedFlow = normalizeElementTypes(flow);\r\n\r\n  // Dann die Einwicklung erzwingen\r\n  normalizedFlow = enforcePatternLibraryElementWrapping(normalizedFlow);\r\n\r\n  // Deep copy erstellen, um das Original nicht zu verändern\r\n  const complexNormalizedFlow = JSON.parse(JSON.stringify(normalizedFlow));\r\n\r\n  // Spezielle Normalisierung für komplexe Strukturen\r\n  if (complexNormalizedFlow.pages_edit) {\r\n    complexNormalizedFlow.pages_edit = complexNormalizedFlow.pages_edit.map((page: any) => {\r\n      // Normalisiere die Elemente rekursiv\r\n      if (page.elements) {\r\n        page.elements = normalizeComplexElements(page.elements);\r\n      }\r\n\r\n      // Normalisiere sub_flows\r\n      if (page.sub_flows) {\r\n        page.sub_flows = page.sub_flows.map((subFlow: any) => {\r\n          // Stelle sicher, dass der Subflow einen type hat\r\n          if (!subFlow.type) {\r\n            subFlow.type = 'SUBFLOW';\r\n          }\r\n\r\n          // Normalisiere die Elemente im Subflow\r\n          if (subFlow.elements) {\r\n            subFlow.elements = normalizeComplexElements(subFlow.elements);\r\n          }\r\n\r\n          return subFlow;\r\n        });\r\n      }\r\n\r\n      return page;\r\n    });\r\n  }\r\n\r\n  // Validiere die Struktur\r\n  const validationResult = validateFlowStructure(complexNormalizedFlow);\r\n  if (!validationResult.valid) {\r\n    console.warn('[normalizeComplexStructure] Validierungsfehler:', validationResult.errors);\r\n  }\r\n\r\n  return complexNormalizedFlow;\r\n};\r\n\r\n/**\r\n * Normalisiert komplexe Elementstrukturen rekursiv\r\n * @param elements Die zu normalisierenden Elemente\r\n * @returns Die normalisierten Elemente\r\n */\r\nconst normalizeComplexElements = (elements: any[]): any[] => {\r\n  return elements.map((elementWrapper: any) => {\r\n    if (!elementWrapper.element) {\r\n      return elementWrapper;\r\n    }\r\n\r\n    const element = elementWrapper.element;\r\n\r\n    // Normalisiere verschachtelte Elemente\r\n    if (element.pattern_type === 'GroupUIElement' && element.elements) {\r\n      element.elements = normalizeComplexElements(element.elements);\r\n    } else if (element.pattern_type === 'ArrayUIElement' && element.elements) {\r\n      element.elements = normalizeComplexElements(element.elements);\r\n    } else if (element.pattern_type === 'CustomUIElement') {\r\n      // Normalisiere Elemente in CustomUIElement\r\n      if (element.elements) {\r\n        element.elements = normalizeComplexElements(element.elements);\r\n      }\r\n\r\n      // Normalisiere sub_flows in CustomUIElement\r\n      if (element.sub_flows) {\r\n        element.sub_flows = element.sub_flows.map((subFlow: any) => {\r\n          // Stelle sicher, dass der Subflow einen type hat\r\n          if (!subFlow.type) {\r\n            subFlow.type = element.type || 'SUBFLOW';\r\n          }\r\n\r\n          // Normalisiere die Elemente im Subflow\r\n          if (subFlow.elements) {\r\n            subFlow.elements = normalizeComplexElements(subFlow.elements);\r\n          }\r\n\r\n          return subFlow;\r\n        });\r\n      }\r\n    }\r\n\r\n    // Stelle sicher, dass alle Referenzen auf andere Elemente korrekt sind\r\n    if (element.visibility_condition) {\r\n      element.visibility_condition = normalizeVisibilityCondition(element.visibility_condition);\r\n    }\r\n\r\n    return elementWrapper;\r\n  });\r\n};\r\n"],"names":["TYPE_MAPPINGS","DateUIElement","YEAR","MONTH","DAY","DATE","BooleanUIElement","SingleSelectionUIElement","NumberUIElement","FileUIElement","TextUIElement","StringUIElement","CustomUIElement","normalizeElementTypes","flow","ensureFieldIds","arguments","length","undefined","normalizedFlow","JSON","parse","stringify","id","uuidv4","pages_edit","pages_view","map","page","title","titleText","de","en","elements","elementWrapper","element","normalizeElement","sub_flows","subFlow","type","validationResult","validateFlowStructure","valid","console","warn","errors","ensureFieldId","pattern_type","patternType","typeMapping","field_id","log","field_name","toLowerCase","includes","description","descText","file_type","accepted_types","allowed_file_types","items","options","default","default_value","visibility_condition","normalizeVisibilityCondition","chips","chip","condition","Array","isArray","operator","toUpperCase","conditions","value","children","field","push","forEach","index","elementIndex","elementErrors","validateElement","subFlowIndex","path","ensurePatternLibraryElement","enforcePatternLibraryElementWrapping","wrappedFlow","normalizeComplexStructure","complexNormalizedFlow","normalizeComplexElements"],"sourceRoot":""}